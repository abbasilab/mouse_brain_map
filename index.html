<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Brain Atlas Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #0a0a1a;
            color: #fff;
        }
        #app { display: flex; height: 100vh; }
        #sidebar {
            width: 340px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #0f3460;
            flex-shrink: 0;
        }
        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle { color: #666; font-size: 0.85em; margin-bottom: 20px; }
        h2 {
            font-size: 0.95em;
            color: #fff;
            background: #e94560;
            padding: 8px 12px;
            border-radius: 6px;
            margin: 15px 0 10px;
        }
        .btn-row { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; }
        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary { background: #e94560; color: #fff; }
        .btn-primary:hover { background: #ff6b6b; transform: translateY(-1px); }
        .btn-secondary { background: #0f3460; color: #fff; }
        .btn-secondary:hover { background: #1a5a9a; }
        .btn-small { padding: 4px 8px; font-size: 0.75em; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
        .slider-group input[type="range"] { width: 100%; }
        .select-group { margin: 12px 0; }
        .select-group label { display: block; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
        .select-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #0a0a1a;
            color: #fff;
            font-size: 0.9em;
        }
        #search {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #0a0a1a;
            color: #fff;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        #search::placeholder { color: #555; }
        #search:focus { outline: none; border-color: #e94560; }
        #region-list {
            max-height: calc(100vh - 520px);
            overflow-y: auto;
            border-radius: 6px;
        }
        .region-item {
            display: flex;
            align-items: flex-start;
            padding: 10px;
            margin: 4px 0;
            background: #0a0a1a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .region-item:hover { background: #0f3460; }
        .region-item.selected { border-color: #e94560; background: #1a1a3e; }
        .region-item.hidden { display: none; }
        .region-item input { margin-right: 10px; margin-top: 3px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0; }
        .region-color {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            margin-right: 10px;
            margin-top: 2px;
            border: 2px solid rgba(255,255,255,0.2);
            flex-shrink: 0;
        }
        .region-info { flex: 1; min-width: 0; }
        .region-name { font-size: 0.9em; font-weight: 500; }
        .region-ccf { font-size: 0.75em; color: #888; margin-top: 2px; }
        .region-ccf span { 
            display: inline-block;
            padding: 1px 6px;
            border-radius: 3px;
            margin-right: 4px;
            margin-top: 2px;
        }
        .ccf1-tag { background: rgba(233, 69, 96, 0.3); }
        .ccf2-tag { background: rgba(15, 52, 96, 0.5); }
        .region-meta { font-size: 0.7em; color: #555; margin-top: 2px; }
        #viewer { flex: 1; position: relative; min-width: 0; }
        #loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading-text { margin-top: 15px; text-align: center; }
        #progress-container { width: 250px; margin-top: 20px; }
        #progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            width: 0%;
            transition: width 0.3s;
        }
        #progress-detail { font-size: 0.8em; color: #666; text-align: center; }
        #stats {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 0.85em;
        }
        #stats div { margin: 3px 0; }
        #stats span { color: #e94560; font-weight: 500; }
        #help {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #888;
        }
        #help kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
        }
        .color-mode-row {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        .color-mode-btn {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75em;
            border: 1px solid #0f3460;
            background: transparent;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-mode-btn:hover { background: #0f3460; color: #fff; }
        .color-mode-btn.active { background: #e94560; border-color: #e94560; color: #fff; }
        
        @media (max-width: 768px) {
            #app { flex-direction: column; }
            #sidebar { width: 100%; height: 50vh; }
            #viewer { height: 50vh; }
            #region-list { max-height: calc(50vh - 400px); }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <h1>ðŸ§  Brain Atlas Viewer</h1>
            <p class="subtitle">Interactive 3D Visualization</p>
            
            <div class="btn-row">
                <button class="btn btn-primary" onclick="selectAll()">Select All</button>
                <button class="btn btn-secondary" onclick="deselectAll()">Clear</button>
                <button class="btn btn-secondary" onclick="invertSelection()">Invert</button>
            </div>
            
            <div class="slider-group">
                <label>Opacity: <span id="opacity-val">1.0</span></label>
                <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="1">
            </div>
            
            <div class="select-group">
                <label>Color By:</label>
                <div class="color-mode-row">
                    <button class="color-mode-btn active" onclick="setColorMode('region')" id="btn-color-region">Region</button>
                    <button class="color-mode-btn" onclick="setColorMode('ccf1')" id="btn-color-ccf1">CCF Level 1</button>
                    <button class="color-mode-btn" onclick="setColorMode('ccf2')" id="btn-color-ccf2">CCF Level 2</button>
                </div>
            </div>
            
            <div class="select-group">
                <label>Filter by CCF Level 1:</label>
                <select id="filter-ccf1" onchange="applyFilters()">
                    <option value="">All</option>
                </select>
            </div>
            
            <div class="select-group">
                <label>Filter by CCF Level 2:</label>
                <select id="filter-ccf2" onchange="applyFilters()">
                    <option value="">All</option>
                </select>
            </div>
            
            <input type="text" id="search" placeholder="ðŸ” Search regions..." oninput="applyFilters()">
            
            <h2>Regions (<span id="count">0</span> / <span id="total-count">0</span>)</h2>
            <div id="region-list"></div>
        </div>
        
        <div id="viewer">
            <div id="loading-overlay">
                <div>
                    <div class="spinner"></div>
                    <p id="loading-text">Loading data...</p>
                    <div id="progress-container">
                        <div id="progress-bar"><div id="progress-fill"></div></div>
                        <div id="progress-detail">Initializing...</div>
                    </div>
                </div>
            </div>
            
            <div id="stats">
                <div>Regions: <span id="stat-regions">0</span></div>
                <div>Vertices: <span id="stat-vertices">0</span></div>
                <div>Triangles: <span id="stat-triangles">0</span></div>
            </div>
            
            <div id="help">
                <kbd>Left</kbd> Rotate
                <kbd>Right</kbd> Pan
                <kbd>Scroll</kbd> Zoom
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        const NUM_DATA_FILES = 8;
        const CCF1_COLORS = {"CB": [0.85, 0.255, 0.255], "CTXsp": [0.255, 0.429, 0.85], "HIP": [0.602, 0.85, 0.255], "HY": [0.85, 0.255, 0.776], "Isocortex": [0.255, 0.85, 0.751], "LSX": [0.85, 0.577, 0.255], "MB": [0.403, 0.255, 0.85], "MY": [0.28, 0.85, 0.255], "OLF": [0.85, 0.255, 0.454], "P": [0.255, 0.628, 0.85], "PAL": [0.801, 0.85, 0.255], "RHP": [0.725, 0.255, 0.85], "STRd": [0.255, 0.85, 0.552], "STRv": [0.85, 0.378, 0.255], "TH": [0.255, 0.306, 0.85], "Unknown": [0.479, 0.85, 0.255], "VS": [0.85, 0.255, 0.653], "fiber tracts": [0.255, 0.827, 0.85], "sAMY": [0.85, 0.7, 0.255]};
        const CCF2_COLORS = {"AAA": [0.9, 0.63, 0.225], "ACAd": [0.433, 0.225, 0.9], "ACAv": [0.225, 0.9, 0.236], "ACB": [0.9, 0.225, 0.411], "AD": [0.225, 0.608, 0.9], "AHN-ASO": [0.805, 0.9, 0.225], "AId": [0.798, 0.225, 0.9], "AIp": [0.225, 0.9, 0.601], "AIv": [0.9, 0.404, 0.225], "AM": [0.225, 0.243, 0.9], "AN": [0.44, 0.9, 0.225], "AOB": [0.9, 0.225, 0.637], "AON": [0.225, 0.834, 0.9], "AP-DCN-ECU": [0.9, 0.769, 0.225], "APN": [0.573, 0.225, 0.9], "AQ": [0.225, 0.9, 0.376], "ARH": [0.9, 0.225, 0.271], "AUDp": [0.225, 0.468, 0.9], "AUDv": [0.665, 0.9, 0.225], "AV": [0.9, 0.225, 0.862], "AVP-MPO-PD": [0.225, 0.9, 0.741], "AVPV": [0.9, 0.544, 0.225], "BA-MEA": [0.347, 0.225, 0.9], "BLA": [0.3, 0.9, 0.225], "BMA": [0.9, 0.225, 0.497], "BST-BAC": [0.225, 0.694, 0.9], "CA1": [0.891, 0.9, 0.225], "CA3": [0.712, 0.225, 0.9], "CEA": [0.225, 0.9, 0.515], "CENT": [0.9, 0.318, 0.225], "CLA": [0.225, 0.329, 0.9], "CM": [0.526, 0.9, 0.225], "CN": [0.9, 0.225, 0.723], "COPY": [0.225, 0.9, 0.88], "CP": [0.9, 0.683, 0.225], "CS": [0.486, 0.225, 0.9], "CUL": [0.225, 0.9, 0.289], "CUN": [0.9, 0.225, 0.358], "DEC": [0.225, 0.555, 0.9], "DG": [0.752, 0.9, 0.225], "DMH": [0.852, 0.225, 0.9], "DP": [0.225, 0.9, 0.655], "DTN": [0.9, 0.458, 0.225], "ECT": [0.261, 0.225, 0.9], "ENT": [0.386, 0.9, 0.225], "EP": [0.9, 0.225, 0.583], "FL": [0.225, 0.78, 0.9], "FN-VeCB": [0.9, 0.823, 0.225], "FOTU": [0.626, 0.225, 0.9], "FS": [0.225, 0.9, 0.429], "GENv": [0.9, 0.232, 0.225], "GPe": [0.225, 0.415, 0.9], "GPi": [0.612, 0.9, 0.225], "GRN": [0.9, 0.225, 0.809], "GU": [0.225, 0.9, 0.794], "HATA": [0.9, 0.597, 0.225], "IA": [0.4, 0.225, 0.9], "IC": [0.247, 0.9, 0.225], "IG": [0.9, 0.225, 0.444], "ILA": [0.225, 0.641, 0.9], "IO": [0.838, 0.9, 0.225], "IP": [0.765, 0.225, 0.9], "IRN-ACVII-AMB-LIN": [0.225, 0.9, 0.568], "LA": [0.9, 0.371, 0.225], "LAV": [0.225, 0.276, 0.9], "LD": [0.473, 0.9, 0.225], "LDT": [0.9, 0.225, 0.67], "LGd": [0.225, 0.866, 0.9], "LH": [0.9, 0.737, 0.225], "LHA": [0.54, 0.225, 0.9], "LM": [0.225, 0.9, 0.343], "LP": [0.9, 0.225, 0.304], "LPO": [0.225, 0.501, 0.9], "LRN": [0.698, 0.9, 0.225], "LSc": [0.9, 0.225, 0.895], "LSr": [0.225, 0.9, 0.708], "LSv": [0.9, 0.511, 0.225], "MARN": [0.314, 0.225, 0.9], "MD": [0.333, 0.9, 0.225], "MDRN": [0.9, 0.225, 0.53], "ME": [0.225, 0.727, 0.9], "MG": [0.9, 0.876, 0.225], "MH": [0.679, 0.225, 0.9], "MM": [0.225, 0.9, 0.482], "MOB": [0.9, 0.285, 0.225], "MOp": [0.225, 0.362, 0.9], "MOs": [0.559, 0.9, 0.225], "MPN": [0.9, 0.225, 0.756], "MPT-NOT-OP-PPT": [0.225, 0.9, 0.847], "MRN": [0.9, 0.65, 0.225], "MSC": [0.453, 0.225, 0.9], "MV": [0.225, 0.9, 0.256], "MY": [0.9, 0.225, 0.391], "NI": [0.225, 0.587, 0.9], "NLL": [0.784, 0.9, 0.225], "NLOT-COA-PAA-TR": [0.819, 0.225, 0.9], "NOD": [0.225, 0.9, 0.622], "NPC": [0.9, 0.425, 0.225], "NTB": [0.228, 0.225, 0.9], "NTS": [0.419, 0.9, 0.225], "ORBl": [0.9, 0.225, 0.616], "ORBm": [0.225, 0.813, 0.9], "ORBvl": [0.9, 0.79, 0.225], "OT": [0.593, 0.225, 0.9], "P5-Acs5-PC5-I5": [0.225, 0.9, 0.396], "PA": [0.9, 0.225, 0.251], "PAG-MEV-SCO": [0.225, 0.448, 0.9], "PAR": [0.645, 0.9, 0.225], "PARN": [0.9, 0.225, 0.842], "PB": [0.225, 0.9, 0.761], "PCG": [0.9, 0.564, 0.225], "PF": [0.367, 0.225, 0.9], "PFL": [0.28, 0.9, 0.225], "PG": [0.9, 0.225, 0.477], "PGRNd": [0.225, 0.674, 0.9], "PGRNl": [0.871, 0.9, 0.225], "PH": [0.732, 0.225, 0.9], "PHY": [0.225, 0.9, 0.535], "PIL": [0.9, 0.338, 0.225], "PIR": [0.225, 0.309, 0.9], "PL": [0.505, 0.9, 0.225], "PMd-PMv": [0.9, 0.225, 0.702], "PO": [0.225, 0.899, 0.9], "POST": [0.9, 0.704, 0.225], "PPN": [0.507, 0.225, 0.9], "PRE": [0.225, 0.9, 0.31], "PRM": [0.9, 0.225, 0.337], "PRNc": [0.225, 0.534, 0.9], "PRNr": [0.731, 0.9, 0.225], "PS": [0.872, 0.225, 0.9], "PST-PSTN-STN": [0.225, 0.9, 0.675], "PSV": [0.9, 0.478, 0.225], "PT": [0.281, 0.225, 0.9], "PVH": [0.366, 0.9, 0.225], "PVHd": [0.9, 0.225, 0.563], "PVT": [0.225, 0.76, 0.9], "PVi": [0.9, 0.843, 0.225], "PVp": [0.646, 0.225, 0.9], "PVpo-VMPO": [0.225, 0.9, 0.449], "PYR": [0.9, 0.252, 0.225], "ProS": [0.225, 0.395, 0.9], "RAmb": [0.592, 0.9, 0.225], "RE-Xi": [0.9, 0.225, 0.789], "RN": [0.225, 0.9, 0.814], "RPF": [0.9, 0.617, 0.225], "RSPagl": [0.42, 0.225, 0.9], "RSPd": [0.227, 0.9, 0.225], "RSPv": [0.9, 0.225, 0.423], "RT": [0.225, 0.62, 0.9], "SAG-PBG": [0.817, 0.9, 0.225], "SCH": [0.786, 0.225, 0.9], "SCm": [0.225, 0.9, 0.589], "SCs": [0.9, 0.392, 0.225], "SFO": [0.225, 0.255, 0.9], "SI": [0.452, 0.9, 0.225], "SIM": [0.9, 0.225, 0.649], "SNr": [0.225, 0.846, 0.9], "SOC": [0.9, 0.757, 0.225], "SPA": [0.56, 0.225, 0.9], "SPFp": [0.225, 0.9, 0.363], "SPIV": [0.9, 0.225, 0.284], "SPVC": [0.225, 0.481, 0.9], "SPVI": [0.678, 0.9, 0.225], "SPVO": [0.9, 0.225, 0.875], "SSp-bfd": [0.225, 0.9, 0.728], "SSp-ll": [0.9, 0.531, 0.225], "SSp-m": [0.334, 0.225, 0.9], "SSp-n": [0.313, 0.9, 0.225], "SSp-tr": [0.9, 0.225, 0.51], "SSp-ul": [0.225, 0.707, 0.9], "SSs": [0.9, 0.896, 0.225], "SUB": [0.699, 0.225, 0.9], "SUM": [0.225, 0.9, 0.502], "SUV": [0.9, 0.306, 0.225], "TEa": [0.225, 0.341, 0.9], "TM": [0.538, 0.9, 0.225], "TRN": [0.9, 0.225, 0.735], "TRS": [0.225, 0.9, 0.868], "TT": [0.9, 0.671, 0.225], "TU": [0.474, 0.225, 0.9], "UVU": [0.225, 0.9, 0.277], "Unknown": [0.9, 0.225, 0.37], "V": [0.225, 0.567, 0.9], "V3": [0.764, 0.9, 0.225], "V4": [0.839, 0.225, 0.9], "VAL": [0.225, 0.9, 0.642], "VII": [0.9, 0.445, 0.225], "VISC": [0.248, 0.225, 0.9], "VISa": [0.399, 0.9, 0.225], "VISl": [0.9, 0.225, 0.596], "VISp": [0.225, 0.793, 0.9], "VISpl": [0.9, 0.81, 0.225], "VISpor": [0.613, 0.225, 0.9], "VISrl": [0.225, 0.9, 0.416], "VL": [0.9, 0.225, 0.231], "VM": [0.225, 0.428, 0.9], "VMH": [0.625, 0.9, 0.225], "VPL": [0.9, 0.225, 0.822], "VPM": [0.225, 0.9, 0.781], "VTA": [0.9, 0.584, 0.225], "XII": [0.388, 0.225, 0.9], "ZI": [0.259, 0.9, 0.225], "cbf": [0.9, 0.225, 0.456], "cm": [0.225, 0.653, 0.9], "fiber tracts": [0.85, 0.9, 0.225], "lfbs": [0.753, 0.225, 0.9], "mfbs": [0.225, 0.9, 0.556]};
        
        let scene, camera, renderer, controls;
        let allRegions = {};
        let allColors = {};
        let allCCF = {};
        let meshes = {};
        let currentOpacity = 1.0;
        let colorMode = 'region';  // 'region', 'ccf1', 'ccf2'
        
        async function init() {
            setupThreeJS();
            
            try {
                await loadAllDataFiles();
                populateFilters();
                renderRegionList();
                document.getElementById('loading-overlay').style.display = 'none';
            } catch (e) {
                document.getElementById('loading-text').textContent = 'Error: ' + e.message;
                console.error(e);
            }
            
            window.addEventListener('resize', onResize);
            document.getElementById('opacity').addEventListener('input', updateOpacity);
            
            animate();
        }
        
        function setupThreeJS() {
            const viewer = document.getElementById('viewer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, viewer.clientWidth / viewer.clientHeight, 0.1, 100000);
            camera.position.set(5000, 5000, 5000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            viewer.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(1, 1, 1);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
            light2.position.set(-1, -1, -1);
            scene.add(light2);
        }
        
        async function loadAllDataFiles() {
            for (let i = 1; i <= NUM_DATA_FILES; i++) {
                const filename = `data_${i}.json`;
                document.getElementById('loading-text').textContent = `Loading ${filename}...`;
                document.getElementById('progress-detail').textContent = `File ${i} of ${NUM_DATA_FILES}`;
                document.getElementById('progress-fill').style.width = `${((i-1) / NUM_DATA_FILES) * 100}%`;
                
                try {
                    const response = await fetch(filename);
                    if (!response.ok) throw new Error(`Failed to load ${filename}`);
                    
                    const data = await response.json();
                    
                    Object.assign(allRegions, data.regions);
                    Object.assign(allColors, data.colors);
                    Object.assign(allCCF, data.ccf || {});
                    
                    document.getElementById('progress-fill').style.width = `${(i / NUM_DATA_FILES) * 100}%`;
                    
                } catch (e) {
                    console.error(`Error loading ${filename}:`, e);
                }
            }
            
            document.getElementById('total-count').textContent = Object.keys(allRegions).length;
            document.getElementById('loading-text').textContent = 'Processing...';
        }
        
        function populateFilters() {
            const ccf1Set = new Set();
            const ccf2Set = new Set();
            
            Object.values(allCCF).forEach(ccf => {
                if (ccf.ccf_level1) ccf1Set.add(ccf.ccf_level1);
                if (ccf.ccf_level2) ccf2Set.add(ccf.ccf_level2);
            });
            
            const ccf1Select = document.getElementById('filter-ccf1');
            const ccf2Select = document.getElementById('filter-ccf2');
            
            [...ccf1Set].sort().forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                ccf1Select.appendChild(opt);
            });
            
            [...ccf2Set].sort().forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                ccf2Select.appendChild(opt);
            });
        }
        
        function applyFilters() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const ccf1Filter = document.getElementById('filter-ccf1').value;
            const ccf2Filter = document.getElementById('filter-ccf2').value;
            
            let visibleCount = 0;
            
            document.querySelectorAll('.region-item').forEach(item => {
                const id = item.dataset.id;
                const ccf = allCCF[id] || {};
                
                let visible = true;
                
                if (searchTerm && !id.includes(searchTerm)) {
                    visible = false;
                }
                if (ccf1Filter && ccf.ccf_level1 !== ccf1Filter) {
                    visible = false;
                }
                if (ccf2Filter && ccf.ccf_level2 !== ccf2Filter) {
                    visible = false;
                }
                
                item.classList.toggle('hidden', !visible);
                if (visible) visibleCount++;
            });
            
            document.getElementById('count').textContent = visibleCount;
        }
        
        function setColorMode(mode) {
            colorMode = mode;
            
            // Update button states
            document.querySelectorAll('.color-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-color-${mode}`).classList.add('active');
            
            // Update all existing meshes
            Object.keys(meshes).forEach(id => {
                if (meshes[id] && meshes[id].material) {
                    const color = getColorForRegion(id);
                    meshes[id].material.color.setRGB(color[0], color[1], color[2]);
                }
            });
            
            // Update list colors
            renderRegionList();
        }
        
        function getColorForRegion(id) {
            if (colorMode === 'ccf1') {
                const ccf = allCCF[id];
                if (ccf && ccf.ccf_level1 && CCF1_COLORS[ccf.ccf_level1]) {
                    return CCF1_COLORS[ccf.ccf_level1];
                }
            } else if (colorMode === 'ccf2') {
                const ccf = allCCF[id];
                if (ccf && ccf.ccf_level2 && CCF2_COLORS[ccf.ccf_level2]) {
                    return CCF2_COLORS[ccf.ccf_level2];
                }
            }
            return allColors[id] || [0.5, 0.5, 0.5];
        }
        
        function renderRegionList() {
            const list = document.getElementById('region-list');
            list.innerHTML = '';
            
            const regionIds = Object.keys(allRegions).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (const id of regionIds) {
                const region = allRegions[id];
                const ccf = allCCF[id] || {};
                const color = getColorForRegion(id);
                const colorHex = `rgb(${Math.round(color[0]*255)},${Math.round(color[1]*255)},${Math.round(color[2]*255)})`;
                
                const item = document.createElement('div');
                item.className = 'region-item' + (meshes[id]?.visible ? ' selected' : '');
                item.dataset.id = id;
                
                const ccf1 = ccf.ccf_level1 || 'Unknown';
                const ccf2 = ccf.ccf_level2 || 'Unknown';
                
                item.innerHTML = `
                    <input type="checkbox" ${meshes[id]?.visible ? 'checked' : ''}>
                    <div class="region-color" style="background:${colorHex}"></div>
                    <div class="region-info">
                        <div class="region-name">Region ${id}</div>
                        <div class="region-ccf">
                            <span class="ccf1-tag">${ccf1}</span>
                            <span class="ccf2-tag">${ccf2}</span>
                        </div>
                        <div class="region-meta">${(region.vc || 0).toLocaleString()} vertices</div>
                    </div>
                `;
                
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const cb = item.querySelector('input');
                        cb.checked = !cb.checked;
                    }
                    toggleRegion(id);
                };
                
                list.appendChild(item);
            }
            
            document.getElementById('count').textContent = regionIds.length;
            applyFilters();
        }
        
        function toggleRegion(id) {
            const item = document.querySelector(`.region-item[data-id="${id}"]`);
            const cb = item.querySelector('input');
            
            if (cb.checked) {
                item.classList.add('selected');
                
                if (!meshes[id]) {
                    const region = allRegions[id];
                    const color = getColorForRegion(id);
                    const mesh = createMesh(region, color);
                    mesh.userData = { id, vc: region.vc, fc: region.fc || 0 };
                    meshes[id] = mesh;
                    scene.add(mesh);
                    
                    if (Object.values(meshes).filter(m => m.visible).length === 1) {
                        fitCamera();
                    }
                } else {
                    meshes[id].visible = true;
                    // Update color in case color mode changed
                    const color = getColorForRegion(id);
                    meshes[id].material.color.setRGB(color[0], color[1], color[2]);
                }
            } else {
                item.classList.remove('selected');
                if (meshes[id]) meshes[id].visible = false;
            }
            
            updateStats();
        }
        
        function createMesh(data, color) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(data.v);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            if (data.t === 'm' && data.f) {
                geometry.setIndex(data.f);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(color[0], color[1], color[2]),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: currentOpacity,
                    metalness: 0.1,
                    roughness: 0.7
                });
                
                return new THREE.Mesh(geometry, material);
            } else {
                const material = new THREE.PointsMaterial({
                    color: new THREE.Color(color[0], color[1], color[2]),
                    size: 3,
                    transparent: true,
                    opacity: currentOpacity
                });
                
                return new THREE.Points(geometry, material);
            }
        }
        
        function fitCamera() {
            const box = new THREE.Box3();
            Object.values(meshes).forEach(m => { if (m.visible) box.expandByObject(m); });
            
            if (!box.isEmpty()) {
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                controls.target.copy(center);
                camera.position.copy(center).add(new THREE.Vector3(maxDim, maxDim, maxDim));
                controls.update();
            }
        }
        
        function updateStats() {
            let regions = 0, vertices = 0, triangles = 0;
            Object.values(meshes).forEach(m => {
                if (m.visible) {
                    regions++;
                    vertices += m.userData.vc || 0;
                    triangles += m.userData.fc || 0;
                }
            });
            document.getElementById('stat-regions').textContent = regions;
            document.getElementById('stat-vertices').textContent = vertices.toLocaleString();
            document.getElementById('stat-triangles').textContent = triangles.toLocaleString();
        }
        
        function updateOpacity() {
            currentOpacity = parseFloat(document.getElementById('opacity').value);
            document.getElementById('opacity-val').textContent = currentOpacity.toFixed(1);
            Object.values(meshes).forEach(m => { if (m.material) m.material.opacity = currentOpacity; });
        }
        
        function selectAll() {
            document.querySelectorAll('.region-item:not(.hidden)').forEach(item => {
                const cb = item.querySelector('input');
                if (!cb.checked) {
                    cb.checked = true;
                    toggleRegion(item.dataset.id);
                }
            });
        }
        
        function deselectAll() {
            document.querySelectorAll('.region-item').forEach(item => {
                const cb = item.querySelector('input');
                if (cb.checked) {
                    cb.checked = false;
                    toggleRegion(item.dataset.id);
                }
            });
        }
        
        function invertSelection() {
            document.querySelectorAll('.region-item:not(.hidden)').forEach(item => {
                const cb = item.querySelector('input');
                cb.checked = !cb.checked;
                toggleRegion(item.dataset.id);
            });
        }
        
        function onResize() {
            const viewer = document.getElementById('viewer');
            camera.aspect = viewer.clientWidth / viewer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>