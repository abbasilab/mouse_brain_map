<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Brain Atlas Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #0a0a1a;
            color: #fff;
        }
        #app { display: flex; height: 100vh; }
        #sidebar {
            width: 340px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #0f3460;
            flex-shrink: 0;
        }
        h1 {
            font-size: 1.3em;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle { color: #666; font-size: 0.85em; margin-bottom: 20px; }
        h2 {
            font-size: 0.95em;
            color: #fff;
            background: #e94560;
            padding: 8px 12px;
            border-radius: 6px;
            margin: 15px 0 10px;
        }
        .btn-row { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; }
        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary { background: #e94560; color: #fff; }
        .btn-primary:hover { background: #ff6b6b; transform: translateY(-1px); }
        .btn-secondary { background: #0f3460; color: #fff; }
        .btn-secondary:hover { background: #1a5a9a; }
        .btn-small { padding: 4px 8px; font-size: 0.75em; }
        .slider-group { margin: 12px 0; }
        .slider-group label { display: block; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
        .slider-group input[type="range"] { width: 100%; }
        .select-group { margin: 12px 0; }
        .select-group label { display: block; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
        .select-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #0a0a1a;
            color: #fff;
            font-size: 0.9em;
        }
        #search {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #0a0a1a;
            color: #fff;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        #search::placeholder { color: #555; }
        #search:focus { outline: none; border-color: #e94560; }
        #region-list {
            max-height: calc(100vh - 520px);
            overflow-y: auto;
            border-radius: 6px;
        }
        .region-item {
            display: flex;
            align-items: flex-start;
            padding: 10px;
            margin: 4px 0;
            background: #0a0a1a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .region-item:hover { background: #0f3460; }
        .region-item.selected { border-color: #e94560; background: #1a1a3e; }
        .region-item.hidden { display: none; }
        .region-item input { margin-right: 10px; margin-top: 3px; width: 18px; height: 18px; cursor: pointer; flex-shrink: 0; }
        .region-color {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            margin-right: 10px;
            margin-top: 2px;
            border: 2px solid rgba(255,255,255,0.2);
            flex-shrink: 0;
        }
        .region-info { flex: 1; min-width: 0; }
        .region-name { font-size: 0.9em; font-weight: 500; }
        .region-ccf { font-size: 0.75em; color: #888; margin-top: 2px; }
        .region-ccf span { 
            display: inline-block;
            padding: 1px 6px;
            border-radius: 3px;
            margin-right: 4px;
            margin-top: 2px;
        }
        .ccf1-tag { background: rgba(233, 69, 96, 0.3); }
        .ccf2-tag { background: rgba(15, 52, 96, 0.5); }
        .region-meta { font-size: 0.7em; color: #555; margin-top: 2px; }
        #viewer { flex: 1; position: relative; min-width: 0; }
        #loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #333;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loading-text { margin-top: 15px; text-align: center; }
        #progress-container { width: 250px; margin-top: 20px; }
        #progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            width: 0%;
            transition: width 0.3s;
        }
        #progress-detail { font-size: 0.8em; color: #666; text-align: center; }
        #stats {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 0.85em;
        }
        #stats div { margin: 3px 0; }
        #stats span { color: #e94560; font-weight: 500; }
        #help {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #888;
        }
        #help kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
        }
        .color-mode-row {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        .color-mode-btn {
            flex: 1;
            padding: 6px 8px;
            font-size: 0.75em;
            border: 1px solid #0f3460;
            background: transparent;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-mode-btn:hover { background: #0f3460; color: #fff; }
        .color-mode-btn.active { background: #e94560; border-color: #e94560; color: #fff; }
        
        @media (max-width: 768px) {
            #app { flex-direction: column; }
            #sidebar { width: 100%; height: 50vh; }
            #viewer { height: 50vh; }
            #region-list { max-height: calc(50vh - 400px); }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <h1>ðŸ§  Brain Atlas Viewer</h1>
            <p class="subtitle">Interactive 3D Visualization</p>
            
            <div class="btn-row">
                <button class="btn btn-primary" onclick="selectAll()">Select All</button>
                <button class="btn btn-secondary" onclick="deselectAll()">Clear</button>
                <button class="btn btn-secondary" onclick="invertSelection()">Invert</button>
            </div>
            
            <div class="slider-group">
                <label>Opacity: <span id="opacity-val">1.0</span></label>
                <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="1">
            </div>
            
            <div class="select-group">
                <label>Color By:</label>
                <div class="color-mode-row">
                    <button class="color-mode-btn active" onclick="setColorMode('region')" id="btn-color-region">Region</button>
                    <button class="color-mode-btn" onclick="setColorMode('ccf1')" id="btn-color-ccf1">CCF Level 1</button>
                    <button class="color-mode-btn" onclick="setColorMode('ccf2')" id="btn-color-ccf2">CCF Level 2</button>
                </div>
            </div>
            
            <div class="select-group">
                <label>Filter by CCF Level 1:</label>
                <select id="filter-ccf1" onchange="applyFilters()">
                    <option value="">All</option>
                </select>
            </div>
            
            <div class="select-group">
                <label>Filter by CCF Level 2:</label>
                <select id="filter-ccf2" onchange="applyFilters()">
                    <option value="">All</option>
                </select>
            </div>
            
            <input type="text" id="search" placeholder="ðŸ” Search regions..." oninput="applyFilters()">
            
            <h2>Regions (<span id="count">0</span> / <span id="total-count">0</span>)</h2>
            <div id="region-list"></div>
        </div>
        
        <div id="viewer">
            <div id="loading-overlay">
                <div>
                    <div class="spinner"></div>
                    <p id="loading-text">Loading data...</p>
                    <div id="progress-container">
                        <div id="progress-bar"><div id="progress-fill"></div></div>
                        <div id="progress-detail">Initializing...</div>
                    </div>
                </div>
            </div>
            
            <div id="stats">
                <div>Regions: <span id="stat-regions">0</span></div>
                <div>Vertices: <span id="stat-vertices">0</span></div>
                <div>Triangles: <span id="stat-triangles">0</span></div>
            </div>
            
            <div id="help">
                <kbd>Left</kbd> Rotate
                <kbd>Right</kbd> Pan
                <kbd>Scroll</kbd> Zoom
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        const NUM_DATA_FILES = 8;
        const CCF1_COLORS = {};
        const CCF2_COLORS = {};
        
        let scene, camera, renderer, controls;
        let allRegions = {};
        let allColors = {};
        let allCCF = {};
        let meshes = {};
        let currentOpacity = 1.0;
        let colorMode = 'region';  // 'region', 'ccf1', 'ccf2'
        
        async function init() {
            setupThreeJS();
            
            try {
                await loadAllDataFiles();
                populateFilters();
                renderRegionList();
                document.getElementById('loading-overlay').style.display = 'none';
            } catch (e) {
                document.getElementById('loading-text').textContent = 'Error: ' + e.message;
                console.error(e);
            }
            
            window.addEventListener('resize', onResize);
            document.getElementById('opacity').addEventListener('input', updateOpacity);
            
            animate();
        }
        
        function setupThreeJS() {
            const viewer = document.getElementById('viewer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(60, viewer.clientWidth / viewer.clientHeight, 0.1, 100000);
            camera.position.set(5000, 5000, 5000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            viewer.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(1, 1, 1);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.3);
            light2.position.set(-1, -1, -1);
            scene.add(light2);
        }
        
        async function loadAllDataFiles() {
            for (let i = 1; i <= NUM_DATA_FILES; i++) {
                const filename = `data_${i}.json`;
                document.getElementById('loading-text').textContent = `Loading ${filename}...`;
                document.getElementById('progress-detail').textContent = `File ${i} of ${NUM_DATA_FILES}`;
                document.getElementById('progress-fill').style.width = `${((i-1) / NUM_DATA_FILES) * 100}%`;
                
                try {
                    const response = await fetch(filename);
                    if (!response.ok) throw new Error(`Failed to load ${filename}`);
                    
                    const data = await response.json();
                    
                    Object.assign(allRegions, data.regions);
                    Object.assign(allColors, data.colors);
                    Object.assign(allCCF, data.ccf || {});
                    
                    document.getElementById('progress-fill').style.width = `${(i / NUM_DATA_FILES) * 100}%`;
                    
                } catch (e) {
                    console.error(`Error loading ${filename}:`, e);
                }
            }
            
            document.getElementById('total-count').textContent = Object.keys(allRegions).length;
            document.getElementById('loading-text').textContent = 'Processing...';
        }
        
        function populateFilters() {
            const ccf1Set = new Set();
            const ccf2Set = new Set();
            
            Object.values(allCCF).forEach(ccf => {
                if (ccf.ccf_level1) ccf1Set.add(ccf.ccf_level1);
                if (ccf.ccf_level2) ccf2Set.add(ccf.ccf_level2);
            });
            
            const ccf1Select = document.getElementById('filter-ccf1');
            const ccf2Select = document.getElementById('filter-ccf2');
            
            [...ccf1Set].sort().forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                ccf1Select.appendChild(opt);
            });
            
            [...ccf2Set].sort().forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                ccf2Select.appendChild(opt);
            });
        }
        
        function applyFilters() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const ccf1Filter = document.getElementById('filter-ccf1').value;
            const ccf2Filter = document.getElementById('filter-ccf2').value;
            
            let visibleCount = 0;
            
            document.querySelectorAll('.region-item').forEach(item => {
                const id = item.dataset.id;
                const ccf = allCCF[id] || {};
                
                let visible = true;
                
                if (searchTerm && !id.includes(searchTerm)) {
                    visible = false;
                }
                if (ccf1Filter && ccf.ccf_level1 !== ccf1Filter) {
                    visible = false;
                }
                if (ccf2Filter && ccf.ccf_level2 !== ccf2Filter) {
                    visible = false;
                }
                
                item.classList.toggle('hidden', !visible);
                if (visible) visibleCount++;
            });
            
            document.getElementById('count').textContent = visibleCount;
        }
        
        function setColorMode(mode) {
            colorMode = mode;
            
            // Update button states
            document.querySelectorAll('.color-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-color-${mode}`).classList.add('active');
            
            // Update all existing meshes
            Object.keys(meshes).forEach(id => {
                if (meshes[id] && meshes[id].material) {
                    const color = getColorForRegion(id);
                    meshes[id].material.color.setRGB(color[0], color[1], color[2]);
                }
            });
            
            // Update list colors
            renderRegionList();
        }
        
        function getColorForRegion(id) {
            if (colorMode === 'ccf1') {
                const ccf = allCCF[id];
                if (ccf && ccf.ccf_level1 && CCF1_COLORS[ccf.ccf_level1]) {
                    return CCF1_COLORS[ccf.ccf_level1];
                }
            } else if (colorMode === 'ccf2') {
                const ccf = allCCF[id];
                if (ccf && ccf.ccf_level2 && CCF2_COLORS[ccf.ccf_level2]) {
                    return CCF2_COLORS[ccf.ccf_level2];
                }
            }
            return allColors[id] || [0.5, 0.5, 0.5];
        }
        
        function renderRegionList() {
            const list = document.getElementById('region-list');
            list.innerHTML = '';
            
            const regionIds = Object.keys(allRegions).sort((a, b) => parseInt(a) - parseInt(b));
            
            for (const id of regionIds) {
                const region = allRegions[id];
                const ccf = allCCF[id] || {};
                const color = getColorForRegion(id);
                const colorHex = `rgb(${Math.round(color[0]*255)},${Math.round(color[1]*255)},${Math.round(color[2]*255)})`;
                
                const item = document.createElement('div');
                item.className = 'region-item' + (meshes[id]?.visible ? ' selected' : '');
                item.dataset.id = id;
                
                const ccf1 = ccf.ccf_level1 || 'Unknown';
                const ccf2 = ccf.ccf_level2 || 'Unknown';
                
                item.innerHTML = `
                    <input type="checkbox" ${meshes[id]?.visible ? 'checked' : ''}>
                    <div class="region-color" style="background:${colorHex}"></div>
                    <div class="region-info">
                        <div class="region-name">Region ${id}</div>
                        <div class="region-ccf">
                            <span class="ccf1-tag">${ccf1}</span>
                            <span class="ccf2-tag">${ccf2}</span>
                        </div>
                        <div class="region-meta">${(region.vc || 0).toLocaleString()} vertices</div>
                    </div>
                `;
                
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const cb = item.querySelector('input');
                        cb.checked = !cb.checked;
                    }
                    toggleRegion(id);
                };
                
                list.appendChild(item);
            }
            
            document.getElementById('count').textContent = regionIds.length;
            applyFilters();
        }
        
        function toggleRegion(id) {
            const item = document.querySelector(`.region-item[data-id="${id}"]`);
            const cb = item.querySelector('input');
            
            if (cb.checked) {
                item.classList.add('selected');
                
                if (!meshes[id]) {
                    const region = allRegions[id];
                    const color = getColorForRegion(id);
                    const mesh = createMesh(region, color);
                    mesh.userData = { id, vc: region.vc, fc: region.fc || 0 };
                    meshes[id] = mesh;
                    scene.add(mesh);
                    
                    if (Object.values(meshes).filter(m => m.visible).length === 1) {
                        fitCamera();
                    }
                } else {
                    meshes[id].visible = true;
                    // Update color in case color mode changed
                    const color = getColorForRegion(id);
                    meshes[id].material.color.setRGB(color[0], color[1], color[2]);
                }
            } else {
                item.classList.remove('selected');
                if (meshes[id]) meshes[id].visible = false;
            }
            
            updateStats();
        }
        
        function createMesh(data, color) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(data.v);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            if (data.t === 'm' && data.f) {
                geometry.setIndex(data.f);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(color[0], color[1], color[2]),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: currentOpacity,
                    metalness: 0.1,
                    roughness: 0.7
                });
                
                return new THREE.Mesh(geometry, material);
            } else {
                const material = new THREE.PointsMaterial({
                    color: new THREE.Color(color[0], color[1], color[2]),
                    size: 3,
                    transparent: true,
                    opacity: currentOpacity
                });
                
                return new THREE.Points(geometry, material);
            }
        }
        
        function fitCamera() {
            const box = new THREE.Box3();
            Object.values(meshes).forEach(m => { if (m.visible) box.expandByObject(m); });
            
            if (!box.isEmpty()) {
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                controls.target.copy(center);
                camera.position.copy(center).add(new THREE.Vector3(maxDim, maxDim, maxDim));
                controls.update();
            }
        }
        
        function updateStats() {
            let regions = 0, vertices = 0, triangles = 0;
            Object.values(meshes).forEach(m => {
                if (m.visible) {
                    regions++;
                    vertices += m.userData.vc || 0;
                    triangles += m.userData.fc || 0;
                }
            });
            document.getElementById('stat-regions').textContent = regions;
            document.getElementById('stat-vertices').textContent = vertices.toLocaleString();
            document.getElementById('stat-triangles').textContent = triangles.toLocaleString();
        }
        
        function updateOpacity() {
            currentOpacity = parseFloat(document.getElementById('opacity').value);
            document.getElementById('opacity-val').textContent = currentOpacity.toFixed(1);
            Object.values(meshes).forEach(m => { if (m.material) m.material.opacity = currentOpacity; });
        }
        
        function selectAll() {
            document.querySelectorAll('.region-item:not(.hidden)').forEach(item => {
                const cb = item.querySelector('input');
                if (!cb.checked) {
                    cb.checked = true;
                    toggleRegion(item.dataset.id);
                }
            });
        }
        
        function deselectAll() {
            document.querySelectorAll('.region-item').forEach(item => {
                const cb = item.querySelector('input');
                if (cb.checked) {
                    cb.checked = false;
                    toggleRegion(item.dataset.id);
                }
            });
        }
        
        function invertSelection() {
            document.querySelectorAll('.region-item:not(.hidden)').forEach(item => {
                const cb = item.querySelector('input');
                cb.checked = !cb.checked;
                toggleRegion(item.dataset.id);
            });
        }
        
        function onResize() {
            const viewer = document.getElementById('viewer');
            camera.aspect = viewer.clientWidth / viewer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>